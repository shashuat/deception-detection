<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="css/global.css">
  <script src="js/d3.v7.min.js"></script>
  <script src="js/toolbox.js"></script>
  <script src="js/message.js"></script>
  <link rel="preload" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&" as="style" onload="this.onload=null;this.rel='stylesheet'">
</head>
<body>
  <div id="loading-screen"><div class="spinner"></div><p></p></div>
  <h2>Video Player</h2>
  <video id="video" autoplay playsinline controls></video>
  <br>
  <button onclick="startLiveStream()">Start Live Stream</button>
  <button onclick="playPresetVideo()">Play Preset Video</button>
  <button onclick="stopStream()">Stop Stream</button>
  <button onclick="saveRecording()">Analyse recording</button>
  
  <script>
    const socket = new WebSocket("ws://127.0.0.1:9000");
    let stream = null; // Store the active stream
    let mediaRecorder;  // Global mediaRecorder variable
    let recordedChunks = [];

    async function startLiveStream() {
        try {
            stopStream(); // Stop any existing stream before starting a new one
            stream = await navigator.mediaDevices.getUserMedia({ video: true });

            const videoElement = document.getElementById('video');
            videoElement.srcObject = stream;
            console.log("Live stream started:", stream.getTracks());

            recordedChunks = [];
            try {
                mediaRecorder = new MediaRecorder(stream, { mimeType: "video/webm; codecs=vp9" });
            } catch (e) {
                console.error("MediaRecorder error:", e);
                return;
            }

            mediaRecorder.ondataavailable = event => {
                console.log("ondataavailable fired");
                if (event.data && event.data.size > 0) {
                    console.log("Data available:", event.data);
                    recordedChunks.push(event.data);
                }
            };

            mediaRecorder.onstop = () => {
                console.log("Recording stopped, chunks collected:", recordedChunks.length);
                saveRecording();
            };

            console.log("Starting recording...");
            mediaRecorder.start(); // Removed timeslice

        } catch (error) {
            console.error("Error accessing camera:", error);
        }
    }


    function playPresetVideo() {
      // Stop any live stream before switching
      stopStream();
      const videoElement = document.getElementById('video');
      videoElement.srcObject = null;
      videoElement.src = "example.mp4"; // Replace with your actual video file URL
      videoElement.play();

      // Wait for the video to load data before capturing the stream
      videoElement.onloadeddata = () => {
        const presetStream = (videoElement.captureStream) ? videoElement.captureStream() : null;
        if (!presetStream) {
          console.warn("Video capture stream not supported or not available.");
          return;
        }

        recordedChunks = [];
        try {
          mediaRecorder = new MediaRecorder(presetStream, { mimeType: "video/webm; codecs=vp9" });
        } catch (e) {
          console.error("MediaRecorder error:", e);
          return;
        }
        
        mediaRecorder.ondataavailable = event => {
          if (event.data && event.data.size > 0) {
            console.log("Data available:", event.data);
            recordedChunks.push(event.data);
          }
        };
        mediaRecorder.onstop = saveRecording;
        // Provide a timeslice to get periodic dataavailable events
        mediaRecorder.start(1000);
        console.log("Recording started.");
      };
    }

    function sendVideoInChunks(blob) {
        const chunkSize = 100 * 1024; // 100KB per chunk
        const totalSize = blob.size;
        let offset = 0;
        let nb_chunks = 0
        send_message("video_chunk_start", {})

        function sendNextChunk() {
            const slice = blob.slice(offset, offset + chunkSize);
            const reader = new FileReader();
            reader.onload = function(e) {
                // e.target.result is a Data URL (base64 encoded)
                const base64Chunk = e.target.result;
                // Send chunk with offset info; you can use a dedicated type like "video_chunk"
                send_message("video_chunk", { 
                    chunk: base64Chunk, 
                    offset: offset, 
                    totalSize: totalSize 
                });
                
                offset += chunkSize;
                nb_chunks += 1
                if (offset < totalSize) {
                sendNextChunk();
                } else {
                // Send a final message indicating completion
                send_message("video_chunk_end", { total_chunks: nb_chunks, totalSize: totalSize });
                console.log("All chunks sent.");
                }
            };
            reader.readAsDataURL(slice);
        }

        sendNextChunk();
    }

    function saveRecording() {
        stopStream()
        if (!recordedChunks || recordedChunks.length === 0) {
          console.warn("No recording available to upload.");
          return;
        }
        const blob = new Blob(recordedChunks, { type: "video/webm" });
        sendVideoInChunks(blob)
    }

    function stopStream() {
      if (stream) {
        stream.getTracks().forEach(track => track.stop()); // Stop all tracks
        stream = null;
      }
    }

    function send_message(type, data, waiting_screen = false, msg = '') {
      if (waiting_screen) {
        d3.select("#loading-screen").style("display", "flex");
        d3.select("#loading-screen p").text(msg);
      }
      socket.send(JSON.stringify({type: type, data: data}));
    }

    async function wait_for_message(type, timeout = 10000, only_content = false) {
      return new Promise((resolve, reject) => {
        let timeout_id = setTimeout(() => {
          socket.removeEventListener("message", check_message);
          reject("Timeout");
        }, timeout);

        function check_message(event) {
          try {
            message = JSON.parse(event.data);
          } catch (e) {
            console.error("Invalid JSON received:", event.data);
            return; // Ignore invalid messages
          }
          if (message && message.type == type) {
            clearTimeout(timeout_id);
            socket.removeEventListener("message", check_message);
            if (only_content && message.data && message.data.message) {
              resolve(message.data.message);
            } else if (only_content && message.data) {
              resolve(message.data);
            } else {
              resolve(message);
            }
          }
        }
        socket.addEventListener("message", check_message);
      });
    }

    socket.onerror = (error) => {
      console.error("Error in WebSocket connection", error);
    };

    socket.onmessage = (event) => {
      const content = read_message(event);
      if (content && content.type == 'error') {
        toast("error", content.data.message);
      }
      console.log("Received message from server", content);
      d3.select("#loading-screen").style("display", "none");
      d3.select("#loading-screen p").text("");
    };

    socket.onopen = () => {
      console.log("Connected to WebSocket server");
      socket.send(JSON.stringify({type: "info", data: { message: "Hello, server!" }}));
    };

    socket.onclose = (event) => {
        const message = `
            <div style="display: flex; flex-direction: column;">
                <span style="color: var(--danger-color); font-size: 1.2rem; margin-bottom: 10px;">Server socket closed, please refresh the page to reconnect.</span>
                <span style="font-style: italic; color: #888;">Make sure the python (backend) server is running. See README for more informations</span>
            </div>
        `
        pop_up_showcase(message);
        console.warn("WebSocket closed:", event)

        if (event.wasClean) {
            console.log(`Closed cleanly, code=${event.code}, reason=${event.reason}`);
        } else {
            console.error("WebSocket closed unexpectedly");
        }
    };
  </script>
</body>
</html>
